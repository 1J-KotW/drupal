## 1. О проекте и мотивации

Мы переносим производственную систему учёта (изделия, операции, рабочее время) на **Drupal**.
Сейчас данные хранятся во внешней **SQLite-базе**, в будущем **Drupal должен стать основной системой** хранения, расчётов и отображения данных.

Тестовое задание — **реальная часть будущего проекта**, а не учебный пример.
По его результатам мы выбираем разработчика для **долгосрочной работы** над системой.

---

## 2. Коротко и простыми словами

Если совсем просто:

Есть старая система на SQLite и есть Drupal.
Нужно написать модуль, который **регулярно переносит данные из SQLite в Drupal**, считает показатели план/факт и показывает их в виде отчёта.

* SQLite — источник данных (только чтение)
* Drupal — монитор и будущий центр системы
* Обновление данных — **по cron**, а не при открытии страниц

---

## 3. Общая структура задания

1. Подключение к SQLite через Drupal Database API
2. Импорт данных из SQLite (ограниченный набор таблиц)
3. Расчёты план / факт / дельта на стороне PHP
4. Сохранение данных в БД Drupal
5. Отображение отчёта в Drupal
6. Корректная архитектура модуля

---

## 4. Цель тестового задания

Необходимо реализовать Drupal-модуль **`factory_bridge`**, который выполняет роль моста между:

* внешней SQLite БД (`workshop_bot.db`),
* и базой данных Drupal.

Модуль должен:

* читать данные об изделиях и операциях из SQLite;
* выполнять расчёты на стороне PHP;
* **по cron** обновлять и сохранять агрегированные данные в Drupal;
* отображать отчёт по изделию в виде таблицы операций.

Важно не только «чтобы работало», но и **как реализована архитектура решения**.

---

## 5. Условия и требования

* **CMS:** Drupal 10 или 11
* **Источник данных:** внешняя SQLite БД `workshop_bot.db`
* **Дизайн и верстка:** не важны
* **Twig:** только для отображения
* **Бизнес-логика и расчёты:** только в PHP

---

## 6. Архитектура и ограничения

### Подключение к SQLite

* Использовать **Drupal Database API**
* Подключение централизованное (не в контроллерах)
* SQLite настроен в `settings.php` как отдельное подключение

Запрещено:

* использовать `new PDO()`, `sqlite_open()` в бизнес-логике;
* выполнять SQL-запросы в Twig;
* размещать бизнес-логику в шаблонах.

---

## 7. Данные (ограничение объёма)

В рамках тестового задания используются **только** таблицы:

* `order_items` — изделия
* `assigned_tasks` — операции
* `work_sessions` — рабочие сессии

Остальные таблицы использовать не требуется.

---

## 8. Расчёты

Для выбранного изделия (`order_items.internal_id`):

* **НЧ План** — `assigned_tasks.applied_norm_hours`
* **Ч Факт** — сумма `(end_time start_time)` по всем `work_sessions` операции

* если `end_time = NULL`, сессия считается активной и **не учитывается в расчёте**
* **Дельта** — План Факт

Все расчёты выполняются **на стороне PHP**.

---

## 9. Обновление данных (важно)

Импорт и пересчёт данных должны выполняться:

* **по cron** (Drupal cron или кастомная cron-задача модуля)
* **не при открытии страниц**
* страницы Drupal работают **только с сохранёнными данными**

---

## 10. Результат

В Drupal должно появиться:

1. Сущность (Node или Custom Entity), в которой хранятся агрегированные данные изделия
2. Страница или блок с отчётом по изделию:

* код / название операции
* НЧ План
* Ч Факт
* Дельта

Визуальное совпадение с существующей системой не требуется.

---

## 11. Вопрос при подаче заявки (обязательный)

**Опишите своими словами:**

1. Какую задачу решает модуль `factory_bridge`
2. Какие данные он получает из SQLite
3. Как и когда обновляются данные в Drupal

Ответ используется для первичного отбора кандидатов. 


1. Модуль `factory_bridge` решает задачу интеграции внешней производственной системы на SQLite с Drupal, обеспечивая автоматический импорт данных об изделиях и операциях, расчёт показателей план/факт/дельта и отображение отчётности в интерфейсе Drupal без нагрузки на страницы.

2. Из SQLite модуль получает данные из трёх таблиц: `order_items` (изделия с internal_id, title, code), `assigned_tasks` (операции с task_code, applied_norm_hours по изделиям) и `work_sessions` (рабочие сессии с start_time, end_time по задачам).

3. Данные обновляются автоматически по cron (стандартный Drupal cron), когда модуль подключается к SQLite, извлекает актуальные данные, выполняет расчёты в PHP и сохраняет агрегированные результаты в сущности Drupal, не при обращении к страницам.